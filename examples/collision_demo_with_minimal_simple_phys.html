<!DOCTYPE html>
<html>

<head>
    <title>Physics Test</title>
</head>

<body>
    <script src="ezdraw.js"></script>
    <script src="simple_phys_minimal.js"></script>
    <script src="simple_phys_ezdraw_renderer.js"></script>
    <script>
        // Friction is always enabled in this simplified demo

        // Setup canvas with proper scaling (y is up, 100px = 1 unit)
        let canvas = ez.createCanvasAndAddToPage()
        ez.centerOrigin = true
        ez.letterBoxCamera(vec2(0, 1), vec2(11.5995, 5.55), true)

        // Utility to create a star composed of convex triangles (CCW order)
        function addStar(
            world,
            x, y,
            points,
            outerRadius,
            innerRadius,
            angleOffset = 0,
            options = {}
        ) {
            if (points < 3) {
                console.error("Cannot create a star with fewer than 3 points.");
                return null;
            }

            const shapes = [];
            const triangles = [];
            const step = (Math.PI * 2) / points;

            const outer = [];
            const inner = [];

            for (let k = 0; k < points; k++) {
                const angleOuter = angleOffset + k * step;
                const angleInner = angleOuter + step / 2;

                outer.push(new Vec2(outerRadius * Math.cos(angleOuter), outerRadius * Math.sin(angleOuter)));
                inner.push(new Vec2(innerRadius * Math.cos(angleInner), innerRadius * Math.sin(angleInner)));
            }

            for (let k = 0; k < points; k++) {
                const O = outer[k];
                const I = inner[k];
                const Op = outer[(k + 1) % points];

                // Add shapes for collision
                shapes.push(new ConvexPolygonShape([new Vec2(0, 0), O, I]));
                shapes.push(new ConvexPolygonShape([new Vec2(0, 0), I, Op]));

                // Keep triangles for inertia calculation
                triangles.push({ v1: O, v2: I });
                triangles.push({ v1: I, v2: Op });
            }

            const isStatic = options.isStatic ?? false;
            const mass = options.mass ?? 1;

            // Compute total area of triangles
            let totalArea = 0;
            for (const tri of triangles) {
                const x1 = tri.v1.x, y1 = tri.v1.y;
                const x2 = tri.v2.x, y2 = tri.v2.y;
                totalArea += Math.abs(x1 * y2 - x2 * y1) * 0.5;
            }

            const density = mass / totalArea;

            // Compute moment of inertia about origin
            let momentOfInertia = 0;
            for (const tri of triangles) {
                const x1 = tri.v1.x, y1 = tri.v1.y;
                const x2 = tri.v2.x, y2 = tri.v2.y;
                const areaTri = Math.abs(x1 * y2 - x2 * y1) * 0.5;
                const mTri = density * areaTri;
                const dot = x1 * x2 + y1 * y2;
                const sum =
                    (x1 * x1 + y1 * y1) +
                    dot +
                    (x2 * x2 + y2 * y2);
                momentOfInertia += (mTri * sum) / 6;
            }

            const star = new PhysObject(x, y, shapes, isStatic, mass, momentOfInertia);
            Object.assign(star, options);

            world.objects.push(star);
            return star;
        }


        // Create physics world
        let world = new PhysWorld()

        // Scene setup functions
        function clearScene() {
            world.objects = [];
            world.constraints = [];
        }

        function setupBoxesScene() {
            clearScene();
            // Add ceiling
            world.addBox(0, 8, 20, 1, 1, true)
            // Add floor
            world.addBox(0, -2, 20, 1, 1, true)
            let box = world.addBox(0, 0, 1, 1)
            let box2 = world.addBox(0, 1, 0.5, 0.5)
            let box3 = world.addBox(0, 1.5, 0.25, 0.25)

        }

        function setupDominoesScene() {
            clearScene();
            // Add floor
            world.addBox(0, -2, 20, 1, 1, true);

            // Create a line of dominoes
            const dominoWidth = 0.15;   // Increased width for better stability
            const dominoHeight = 2.0;  // Doubled height
            const spacing = 0.8;       // Increased spacing for larger dominoes
            const numDominoes = 10;

            for (let i = 0; i < numDominoes; i++) {
                const x = -3 + (i * spacing);
                const domino = world.addBox(x, -1.5 + dominoHeight / 2, dominoWidth, dominoHeight);
                // Add angular velocity to first domino to start chain reaction
                if (i === 0) {
                    domino.angularVelocity = -5;  // Negative value for clockwise rotation
                }
                domino.friction = 0.1;
            }

        }

        function setupStackScene() {
            clearScene();
            // Add floor
            world.addBox(0, -2, 20, 1, 1, true);

            // Create a three-level Stonehenge-like structure
            const pillarWidth = 0.4;
            const pillarHeight = 1.25;
            const crossbeamWidth = 3.5;
            const crossbeamHeight = 0.4;
            const pillarSpacing = 2.0;

            // Bottom level - 3 pillars
            const bottomY = -1.5;
            // Left pillar
            world.addBox(-pillarSpacing, bottomY + pillarHeight / 2, pillarWidth, pillarHeight);
            // Center pillar
            world.addBox(0, bottomY + pillarHeight / 2, pillarWidth, pillarHeight);
            // Right pillar
            world.addBox(pillarSpacing, bottomY + pillarHeight / 2, pillarWidth, pillarHeight);
            // Bottom crossbeam
            world.addBox(0, bottomY + pillarHeight + crossbeamHeight / 2, crossbeamWidth * 1.2, crossbeamHeight);

            // Middle level - 2 pillars
            const middleY = bottomY + pillarHeight + crossbeamHeight;
            // Left pillar
            world.addBox(-pillarSpacing / 2, middleY + pillarHeight / 2, pillarWidth, pillarHeight);
            // Right pillar
            world.addBox(pillarSpacing / 2, middleY + pillarHeight / 2, pillarWidth, pillarHeight);
            // Middle crossbeam
            world.addBox(0, middleY + pillarHeight + crossbeamHeight / 2, crossbeamWidth * 0.8, crossbeamHeight);

            // Top level - 1 pillar
            const topY = middleY + pillarHeight + crossbeamHeight;
            // Center pillar
            world.addBox(0, topY + pillarHeight / 2, pillarWidth, pillarHeight);
            // Top crossbeam
            world.addBox(0, topY + pillarHeight + crossbeamHeight / 2, crossbeamWidth * 0.5, crossbeamHeight);

        }

        // Controls for the simulation
        const controls = {
            "Scene": ["Boxes", "Dominoes", "Stack"]
        };

        // Create GUI
        ez.gui(controls, {
            "Scene": (val) => {
                switch (val) {
                    case "Boxes":
                        setupBoxesScene();
                        break;
                    case "Dominoes":
                        setupDominoesScene();
                        break;
                    case "Stack":
                        setupStackScene();
                        break;
                }
            }
        }, {
            theme: 'minimalist',
            darkMode: (() => {
                // Get theme from URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const theme = urlParams.get('theme');
                return theme !== 'light';
            })(),
            hideControlsButton: true
        });

        // Set up initial scene
        setupBoxesScene();

        // Main animation function
        function update(dt) {
            ez.clear()

            // Draw grid for reference
            ez.ctx.lineWidth = 1
            ez.grid(1, 50).stroke(0xbbbbbb)

            // Draw coordinate axes
            ez.ctx.lineWidth = 1.5
            ez.line(vec2(0, -1000), vec2(0, 1000), { roundToNearestPixel: true }).stroke("grey")
            ez.line(vec2(-1000, 0), vec2(1000, 0), { roundToNearestPixel: true }).stroke("grey")

            // Render physics objects
            PhysRenderer.render(world)

            // Update physics
            world.step(dt)
        }

        // Start the animation with automatic pause on hidden
        ez.callAnimate(update, true);

        PhysRenderer.initMouseControls(world)
    </script>
</body>

</html>