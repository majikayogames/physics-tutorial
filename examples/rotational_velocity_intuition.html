<!DOCTYPE html>
<html>

<head>
    <title>Circle Unrolling Animation with Rotating Line</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@400;600&display=swap">
</head>

<body>
    <script src="ezdraw.js"></script>
    <script>
        // Create canvas with ezdraw
        const canvas = ez.createCanvasAndAddToPage();
        ez.centerOrigin = true;
        ez.letterBoxCamera(vec2(0, 0), vec2(16.72, 8), false)

        // Animation state
        let unrollPercent = 0;
        let circle = { x: 0, y: 0, radius: 1 };
        let circumference = circle.radius * Math.PI * 2;
        let moveSpeed = -Math.PI; // -π per second
        let markerPos = 0;
        let unrollSpeed = -0.6; // -0.6 per second

        // GUI controls
        const controls = {
            "Unroll circle"() {
                unrollSpeed *= -1;
                this.buttonText = unrollSpeed > 0 ? "Back to circle" : "Unroll circle";
            },
            "Show runner": false
        };

        // Create GUI
        ez.gui(controls, {}, {
            theme: 'minimalist',
            darkMode: (() => {
                // Get theme from URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const theme = urlParams.get('theme');
                return theme !== 'light';
            })(),
            hideControlsButton: true
        });

        // Add SVG data for two running poses
        const runnerSvg1 = `
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
    <circle cx="50" cy="25" r="10" fill="#2196F3"/>
    <line x1="50" y1="35" x2="50" y2="65" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="65" x2="35" y2="85" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="65" x2="65" y2="65" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="45" x2="30" y2="55" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="45" x2="70" y2="35" stroke="#2196F3" stroke-width="6"/>
</svg>`;

        const runnerSvg2 = `
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
    <circle cx="50" cy="25" r="10" fill="#2196F3"/>
    <line x1="50" y1="35" x2="50" y2="65" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="65" x2="65" y2="85" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="65" x2="35" y2="65" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="45" x2="70" y2="55" stroke="#2196F3" stroke-width="6"/>
    <line x1="50" y1="45" x2="30" y2="35" stroke="#2196F3" stroke-width="6"/>
</svg>`;

        // Create data URLs for both poses
        const runnerDataUrl1 = 'data:image/svg+xml;base64,' + btoa(runnerSvg1);
        const runnerDataUrl2 = 'data:image/svg+xml;base64,' + btoa(runnerSvg2);

        // Animation timing
        let lastPoseChange = Date.now();
        let currentPose = 1;
        const POSE_CHANGE_INTERVAL = 500; // 0.5 seconds

        function getRunnerPose() {
            const now = Date.now();
            if (now - lastPoseChange > POSE_CHANGE_INTERVAL) {
                currentPose = currentPose === 1 ? 2 : 1;
                lastPoseChange = now;
            }
            return currentPose === 1 ? runnerDataUrl1 : runnerDataUrl2;
        }

        function drawUnrollingCircle(centerX, centerY, radius, unrollPercent, rotation, drawLineAtLength) {
            const pctIsCircle = 1.0 - unrollPercent;
            const circumference = 2 * Math.PI * radius;
            const numArcs = 1000;  // High resolution for accurate marker positioning
            const numDrawPoints = 100;  // Lower resolution for drawing
            const eachArcLength = circumference / numArcs;
            const drawEveryNth = Math.floor(numArcs / numDrawPoints);

            let curPos = vec2(centerX, centerY - radius);
            let angle = 0; // Start from top
            let lineStart, lineEnd;
            rotation = Math.min(rotation, Math.PI * 2 - 0.01);

            // Draw the circle/unrolled shape
            let points = [];
            let lengthSoFar = 0;
            for (let i = 0; i < numArcs; i++) {
                const arcAngle = eachArcLength / radius * pctIsCircle;
                const nextAngle = angle + arcAngle;
                
                // Calculate next position
                const nextX = curPos.x + eachArcLength * Math.cos(angle);
                const nextY = curPos.y + eachArcLength * Math.sin(angle);
                const nextPos = vec2(nextX, nextY);
                
                // Only add points to drawing array at lower resolution
                if (i % drawEveryNth === 0) {
                    points.push(curPos);
                }
                
                const nextLength = lengthSoFar + eachArcLength;
                if (lengthSoFar <= drawLineAtLength && nextLength >= drawLineAtLength) {
                    const t = (drawLineAtLength - lengthSoFar) / (nextLength - lengthSoFar);
                    lineStart = vec2(
                        lerp(curPos.x, nextPos.x, t),
                        lerp(curPos.y, nextPos.y, t)
                    );
                    if (pctIsCircle == 1.0)
                        lineEnd = vec2(centerX, centerY);
                    else
                        lineEnd = vec2(
                            lineStart.x + radius * Math.cos(angle + Math.PI / 2),
                            lineStart.y + radius * Math.sin(angle + Math.PI / 2)
                        );
                }
                
                lengthSoFar = nextLength;
                curPos = nextPos;
                angle = nextAngle;
            }
            // Add the final point
            points.push(curPos);
            
            // Draw the initial circle if not unrolled
            if (unrollPercent == 0.0) {
                ez.circle(vec2(centerX, centerY), radius).fill("#fff");
            }

            // Draw the path
            if (points.length > 1) {
                ez.path(points).stroke("#000", { lineWidth: 1.5, strokeStyle: "#000" });
            }

            // Draw the rotating line
            if (lineStart && lineEnd) {
                if (!controls["Show runner"]) {
                    ez.line(lineStart, lineEnd).stroke("#000", { lineWidth: 1.5, strokeStyle: "#000" });
                }
                
                // Always show the dot
                ez.circle(lineStart, 0.06).fill("#c00");

                if (controls["Show runner"]) {
                    // Draw the runner on the circle/unrolled shape
                    const scale = 0.75;
                    const yOffset = -0.3;
                    ez.image(getRunnerPose(), vec2(lineStart.x, lineStart.y + yOffset), 0, scale).draw();
                }
            }
            ez.image(getRunnerPose(), vec2(-999, -999), 0, 0).draw(); // preload img so doesn't flicker
        }

        function drawLineWithMarker(startX, startY, length, markerPct, markerHeight) {
            // Draw horizontal line with thicker green style
            ez.line(vec2(startX, startY), vec2(startX + length, startY))
                .stroke("#000", { lineWidth: 1.5 });
            
            const markerX = startX + length * markerPct;

            // Always show the dot
            ez.circle(vec2(markerX, startY), 0.06).fill("#c00");
            
            if (!controls["Show runner"]) {
                // Draw vertical marker line only when runner is not shown
                ez.line(vec2(markerX, startY), vec2(markerX, startY - markerHeight))
                    .stroke("#000", { lineWidth: 1.5 });
            } else {
                // Draw the runner figure
                const scale = 0.75;
                const yOffset = -0.3;
                ez.image(getRunnerPose(), vec2(markerX, startY + yOffset), 0, scale).draw();
            }
        }

        // Main animation function
        function update(dt) {
            ez.clear();

            // Draw grid
            ez.grid(1, 50).stroke("#ddd");

            let markerPct = markerPos / circumference;
            let rotation = markerPct * Math.PI * 2;
            let drawLineAtLength = rotation / (2 * Math.PI) * circumference;

            // Update animation state
            markerPos = markerPos + (moveSpeed * dt);
            if (markerPos >= circumference - 0.001) {
                markerPos = circumference - 0.001;
                moveSpeed *= -1;
            } else if (markerPos <= 0.001) {
                markerPos = 0.001;
                moveSpeed *= -1;
            }

            unrollPercent += unrollSpeed * dt;
            unrollPercent = Math.max(0, Math.min(1.0, unrollPercent));

            // Common text options for better formatting
            const textOptions = {
                fontFamily: "'Source Sans Pro', sans-serif",
                fontSize: 4,
                textAlign: 'left',
                textBaseline: 'top',
                lineHeight: 6,
                fontStyle: '500'  // Make it semi-bold like the headers
            };

            // Draw text with improved formatting
            ez.textWorldScaled(
                `Movement Speed: ${moveSpeed < 0 ? "-" : ""}π/s\nLine Length: 2π`,
                vec2(circle.x - 7.5, circle.y - circle.radius * 2.75),
                textOptions
            ).fill("#000");  // Use the primary color from your index
            
            ez.textWorldScaled(
                `${controls["Show runner"] || unrollPercent > 0 ? "Movement" : "Circle Rotation"} Speed: ${(unrollPercent === 0 ? moveSpeed : -moveSpeed) < 0 ? "" : "-"}π${unrollPercent == 0 ? " rad" : ""}/s\n${unrollPercent == 0 ? "Circumference: 2π\nRadius: 1" : "Line Length: 2π"}`,
                vec2(circle.x - 7.5, circle.y - 0.85),
                textOptions
            ).fill("#000");  // Use the primary color from your index

            // Draw the main visualization
            drawUnrollingCircle(circle.x, circle.y, circle.radius, unrollPercent, rotation, drawLineAtLength);
            drawLineWithMarker(circle.x, circle.y - circle.radius * 2, circumference, markerPct, circle.radius);
        }

        // Start the animation with automatic pause on hidden
        ez.callAnimate(update, true);
    </script>
</body>

</html>