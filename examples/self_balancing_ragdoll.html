<!DOCTYPE html>
<html>

<head>
	<title>Self Balancing Ragdoll</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<script src="ezdraw.js"></script>
	<script src="../simple_phys.js"></script>
	<script src="simple_phys_ezdraw_renderer.js"></script>
	<script src="ragdoll_builder_utils.js"></script>
	<script>
		// ──────────────────────────────────────────────────────────────
		// Setup
		// ──────────────────────────────────────────────────────────────
		const canvas = ez.createCanvasAndAddToPage();
		ez.centerOrigin = true;
		ez.letterBoxCamera(vec2(0, -0.8), vec2(6.5, 9).scaled(1.2), true);

		const world = new PhysWorld();
		world.gravity = new Vec2(0, -9.81);
		const fixedDt = 1 / 240; // smaller substep for accuracy
		const maxSubstepsPerFrame = 32; // allow larger catch-up to avoid time dilation

		// ──────────────────────────────────────────────────────────────
		// Limb & Rig helpers
		// ──────────────────────────────────────────────────────────────

		function _shortDiff(a, b) {
			let d = a - b;
			while (d <= -Math.PI) d += 2 * Math.PI;
			while (d > Math.PI) d -= 2 * Math.PI;
			return d;
		}

		class Limb {
			constructor(world, type, params = {}) {
				this.world = world;
				this.type = type;
				this.body = null;
				this.lowerLimitFromCenter = null;
				this.upperLimitFromCenter = null;
				this.centerOffsetFromParent = 0
				this.parentLimb = null
				this.offsetFromJoint = new Vec2(0, 0);

				if (type === "capsule") {
					const { x = 0, y = 0, length = 1, radiusA = 0.2, radiusB = 0.2, isStatic = false, rotation = 0, zIndex = 0 } = params;
					const density = 2.5;
					this.body = world.addCapsule(x, y, length, radiusA, radiusB, density, isStatic);
					this.body.rotation = rotation;
					this.body._renderZIndex = zIndex;
				} else if (type === "circle") {
					const { x = 0, y = 0, radius = 0.5, isStatic = false, rotation = 0, zIndex = 0 } = params;
					this.body = world.addCircle(x, y, radius, 1, isStatic);
					this.body.rotation = rotation;
					this.body._renderZIndex = zIndex;
				} else {
					throw new Error("Invalid limb type");
				}

				if (type === "capsule") {
					this._startOffset = this.body.shapes[1].offset;	// endA
					this._endOffset = this.body.shapes[2].offset;	// endB
				} else {
					this._startOffset = this._endOffset = new Vec2(0, 0);
				}

				this.body.restitution = 0.0;
				this.body.friction = 1.0;
				this.parentJoint = null;
			}

			isColliding() {
				return this.world.constraints.filter(c => (c instanceof ContactConstraint) && (c.bodyA === this.body || c.bodyB === this.body)).length > 0;
			}

			_localAnchor(which) { return which === "end" ? this._endOffset : this._startOffset; }
			getWorldAnchor(which) {
				const r = this._localAnchor(which).rotate(this.body.rotation);
				return this.body.position.add(r);
			}
		}

		class Rig {
			constructor(world, collisionGroupIndex = 2) {
				this.world = world;
				this.limbs = {};
				this.constraints = [];
				this.groupBit = 1 << collisionGroupIndex;
			}

			addLimb(name, type, params = {}, parentName = null, jointOpts = {}) {
				if (this.limbs[name]) throw new Error(`Limb "${name}" already exists`);
				const limb = new Limb(this.world, type, params);
				if (params.rotation === undefined && parentName && this.limbs[parentName])
					limb.body.rotation = this.limbs[parentName].body.rotation + (jointOpts.center ?? 0);
				limb.name = name;
				const { offsetX = 0, offsetY = 0 } = params;
				limb.offsetFromJoint = new Vec2(offsetX, offsetY);

				limb.body.collisionMask = 0x0F0000;
				limb.body.collisionMaskIgnore = 0x0F0000;
				limb.body._renderColorHint = "#FFB3BA";
				//limb.body._renderColorHint = "#FFE5A3";

				this.limbs[name] = limb;

				let joint = null;
				if (parentName) {
					const parent = this.limbs[parentName];
					const anchorA = jointOpts.anchorA ?? "end";
					const anchorB = jointOpts.anchorB ?? "start";

					const worldAnchor = parent.getWorldAnchor(anchorA);
					const localB = limb._localAnchor(anchorB);
					const rotB = localB.rotate(limb.body.rotation);
					limb.body.position = worldAnchor.sub(rotB);

					const parentRot = parent.body.rotation;
					const additionalOffsetRotated = limb.offsetFromJoint.rotate(parentRot);
					limb.body.position = limb.body.position.add(additionalOffsetRotated);

					const centerOffset = jointOpts.center ?? 0;
					const totalRange = jointOpts.limit ?? (Math.PI / 2);
					const halfSpan = totalRange * 0.5;
					const lower = centerOffset - halfSpan;
					const upper = centerOffset + halfSpan;

					if (jointOpts.limit !== undefined) {
						limb.lowerLimitFromCenter = lower;
						limb.upperLimitFromCenter = upper;
						limb.centerOffsetFromParent = centerOffset;
					}
					limb.parentLimb = parent

					joint = this.world.addRevoluteConstraint(parent.body, limb.body, worldAnchor, jointOpts.limit !== undefined ? lower : undefined, jointOpts.limit !== undefined ? upper : undefined);
					joint._originalLimitsRotationRendererHint = -(centerOffset + halfSpan);

					limb.parentJoint = joint;
					this.constraints.push(joint);
				}
				return { limb, joint };
			}

			getCenterOfMass() {
				let totalMass = 0;
				let weightedPosSum = new Vec2(0, 0);

				for (const name in this.limbs) {
					const limb = this.limbs[name];
					const body = limb.body;
					if (body.mass === Infinity) continue;
					const mass = body.mass;
					const pos = body.position;

					totalMass += mass;
					weightedPosSum = weightedPosSum.add(pos.scale(mass));
				}

				if (totalMass === 0) {
					return new Vec2(0, 0); // Or handle as appropriate, maybe return null or throw error
				}

				return weightedPosSum.scale(1 / totalMass);
			}

			toggleJointLimits(show = true) {
				for (const j of this.constraints)
					j._limitsRotationRendererHint = show ? j._originalLimitsRotationRendererHint : undefined;
			}
		}

		// ──────────────────────────────────────────────────────────────
		// FABRIK-based IK chain
		// ──────────────────────────────────────────────────────────────
		class IKChain {
			constructor(rig, limbNames, maxForce = 15, freq = 12, dampingRatio = 2) {
				this.rig = rig;
				this.limbs = limbNames.map(n => rig.limbs[n]);
				this.joints = this.limbs.map(l => l.parentJoint);
				this.maxForce = maxForce;
				this.freq = freq;
				this.dampingRatio = dampingRatio;
				this.segLens = this._getSegLens();
				this.lastSolvedPts = [];
				this.lastTarget = null;
				this.lastRelTargets = [];
				// Seemed to cause more issues than it solved. Disabling first joint limits by default
				this.obeyFirstJointLimits = false;
			}

			_getSegLens() {
				const pts = this._worldPts();
				return pts.slice(1).map((p, i) => p.sub(pts[i]).length());
			}

			_worldPts() {
				const pts = [];
				const base = this.limbs[0].getWorldAnchor("start");
				pts.push(vec2(base.x, base.y));
				for (const l of this.limbs) {
					const e = l.getWorldAnchor("end");
					pts.push(vec2(e.x, e.y));
				}
				return pts;
			}

			_runFabrik(chain, target, limbLimits, tol = 0.001, maxIt = 15) {
				chain = chain.map((c) => vec2(c))
				target = vec2(target)
				const base = chain[0].clone();
				const totalLen = this.segLens.reduce((s, l) => s + l, 0);
				const segLens = chain.slice(1).map((c, i) => c.sub(chain[i]).length())

				const applyConstraintsToSegment = (i) => {
					const limits = limbLimits[i]
					if (limits && limits.lower !== null && limits.upper !== null) {
						if (i === 0 && this.obeyFirstJointLimits) { // Need centerPoint as a reference point for limits of first limb
							let rootSegment = chain[1].sub(chain[0]);
							let rootDesiredWorldAngle = rootSegment.angle()
							let rootAngleRelToCenter = _shortDiff(rootSegment.angle(), limits.centerPoint);
							let centerDiff = rootAngleRelToCenter - rootDesiredWorldAngle
							const halfSpan = (limits.upper - limits.lower) / 2
							const constrainedRootAngleRelToCenter = Math.max(-halfSpan, Math.min(halfSpan, rootAngleRelToCenter));
							if (constrainedRootAngleRelToCenter !== rootAngleRelToCenter) {
								chain[1] = chain[0].add(new Vec2(1, 0).rotate(constrainedRootAngleRelToCenter - centerDiff).scale(segLens[0]));
							}
						}
						else if (i > 0) {
							const parentSegment = chain[i].sub(chain[i - 1]);
							const childSegmentDesired = chain[i + 1].sub(chain[i]); // Direction based on current state

							const parentAngle = parentSegment.angle();
							const childDesiredWorldAngle = childSegmentDesired.angle();
							let desiredRelAngle = _shortDiff(childDesiredWorldAngle, parentAngle);

							const clampedRelAngle = Math.max(limits.lower, Math.min(limits.upper, desiredRelAngle));

							if (clampedRelAngle !== desiredRelAngle) {
								const constrainedWorldAngle = parentAngle + clampedRelAngle;
								chain[i + 1] = chain[i].add(new Vec2(1, 0).rotate(constrainedWorldAngle).scale(segLens[i]));
							}
						}
					}
				}

				// Case for when the target is further than the total length of the chain. Stretch towards it while respecting joint limits
				if (target.sub(base).length() > totalLen) {
					const dir = target.sub(base).normalize();
					for (let i = 1; i < chain.length; i++) {
						chain[i] = chain[i - 1].add(dir.scale(this.segLens[i - 1]));
						applyConstraintsToSegment(i - 1);
					}
					return chain;
				}

				const flipChain = (chain) => {
					chain = chain.map(p => vec2(p))
					const axis = target.sub(base).normalize();   // unit direction from base to target
					for (let i = 1; i < chain.length; i++) {
						const v = chain[i].sub(base);
						const proj = axis.scale(v.dot(axis));
						const perp = v.sub(proj);
						const flipped = proj.sub(perp);
						chain[i] = base.add(flipped);
					}
					return chain
				}

				const getError = (chain) => {
					const effector = chain[chain.length - 1];
					const diff = effector.sub(target);
					return diff.length();
				}

				let normalChain = chain;
				let flippedChain = flipChain(chain);
				let normalErr, flippedErr;

				// Had some issues with convergence, running fabrik from both directions seemed to fix it
				for (let tri_f of ["normal", "flipped"]) {
					chain = tri_f === "flipped" ? flippedChain : normalChain;
					for (let iter = 0; iter < maxIt; iter++) {
						// 1) measure current error
						const effector = chain[chain.length - 1];
						const diff = effector.sub(target);
						const err = diff.length();

						// 2) convergence check
						if (err < tol) return chain;

						// 3) Forward pass (tip → base)
						chain[chain.length - 1] = target.clone();
						for (let i = chain.length - 2; i >= 0; i--) {
							const len = segLens[i];
							const dir = chain[i + 1].sub(chain[i]).normalize();
							chain[i] = chain[i + 1].sub(dir.scale(len));
							applyConstraintsToSegment(i);
						}

						// 4) Backward pass (base → tip)
						chain[0] = base.clone();
						for (let i = 0; i < chain.length - 1; i++) {
							const len = segLens[i];
							const dir = chain[i + 1].sub(chain[i]).normalize();
							chain[i + 1] = chain[i].add(dir.scale(len));
							applyConstraintsToSegment(i);
						}
					}
				}

				return getError(normalChain) < getError(flippedChain) ? normalChain : flippedChain;
			}

			solve(target) {
				this.lastTarget = target;
				const pts = this._worldPts();
				const limbLimits = this.limbs.map(l => ({ lower: l.lowerLimitFromCenter, upper: l.upperLimitFromCenter, centerPoint: l.centerOffsetFromParent + l.parentLimb.body.rotation }));
				if (limbLimits[0].lower !== null && limbLimits[0].upper !== null) {
					limbLimits[0].centerPoint = Math.atan2(Math.sin(limbLimits[0].centerPoint), Math.cos(limbLimits[0].centerPoint))
					limbLimits[0].lower += limbLimits[0].centerPoint
					limbLimits[0].upper += limbLimits[0].centerPoint
				}
				const solved = this._runFabrik(pts.map(p => p.clone()), target, limbLimits);
				this.lastSolvedPts = solved;
				this.lastRelTargets = [];

				let lastDiff = 0;
				for (let i = 0; i < this.joints.length; i++) {
					const joint = this.joints[i];
					if (!joint) continue;

					const dir = solved[i + 1].sub(solved[i]);
					const desiredWorld = dir.angle();
					let relTarget = _shortDiff(desiredWorld, joint.bodyA.rotation + lastDiff);
					lastDiff = relTarget - (joint.bodyB.rotation - joint.bodyA.rotation);

					joint.setMotorTargetAngle(
						relTarget,				// no extra negation
						this.maxForce,
						this.freq,
						this.dampingRatio,
						true					// wrap to closest
					);

					this.lastRelTargets.push(relTarget);
				}

				const firstLimbPos = this.limbs[0].body.position;
				const firstLimbRot = this.limbs[0].body.rotation;
				this.lastSolvedPtsRelativeToLimb = this.lastSolvedPts.map(pt => {
					const translatedPt = pt.sub(firstLimbPos);
					// Assuming vec2_rotate exists and rotates a vector by an angle
					return translatedPt.rotate(-firstLimbRot);
				});
			}

			clearDebugDraw() {
				this.lastSolvedPtsRelativeToLimb = [];
				this.lastSolvedPtsWorld = [];
				this.lastRelTargets = [];
			}

			drawDebug(ctx = ez.ctx, color = "rgba(173, 216, 230, 0.7)", lineWidth = 2) {
				if (!this.lastSolvedPtsRelativeToLimb || this.lastSolvedPtsRelativeToLimb.length < 2) return;

				const firstLimbPos = this.limbs[0].body.position;
				const firstLimbRot = this.limbs[0].body.rotation;
				this.lastSolvedPtsWorld = this.lastSolvedPtsRelativeToLimb.map(pt => pt.rotated(firstLimbRot).add(firstLimbPos));

				ctx.save();
				ctx.lineWidth = lineWidth;

				// Draw line segments using ez.line
				for (let i = 1; i < this.lastSolvedPts.length; i++) {
					ez.line(this.lastSolvedPtsWorld[i - 1], this.lastSolvedPtsWorld[i]).stroke(color);
				}

				// Draw points
				for (const pt of this.lastSolvedPtsWorld) {
					ez.circle(pt, 0.05).fill(color);
				}

				// Draw the target circle
				if (this.lastTarget && this._drawTargetDebug) {
					ez.circle(this.lastTarget, 0.1).fill("rgba(255, 0, 0, 0.25)");
				}

				// Draw motor target angles
				ctx.lineWidth = 1;
				for (let i = 0; i < this.joints.length; i++) {
					const joint = this.joints[i];
					if (!joint || i >= this.lastRelTargets.length) continue;

					const relTarget = this.lastRelTargets[i];
					const anchor = this.limbs[i].getWorldAnchor("start");
					const parentRot = joint.bodyA.rotation; // Physics world rotation (Y-up)

					// Calculate target world rotation (Physics Y-up)
					const targetWorldRotPhys = parentRot + relTarget;
					// Convert to drawing world rotation (Canvas Y-down)
					const targetWorldRotDraw = targetWorldRotPhys;

					const dir = vec2(Math.cos(targetWorldRotDraw), Math.sin(targetWorldRotDraw));
					const endPt = anchor.add(dir.scale(0.4)); // Draw a short line

					ez.line(anchor, endPt).stroke("black");
				}

				ctx.restore();
			}
		}

		// ──────────────────────────────────────────────────────────────
		// Leg + Arm balance / stepping controller  (v3)
		// ──────────────────────────────────────────────────────────────
		const groundY = -3.0;
		const elbowRestAngle = 0.3;

		class StepController {
			constructor(rig) {
				// --------------- legs ---------------
				this.legR = {
					chain: new IKChain(rig, ["r_thigh", "r_calf"]),
					knee: rig.limbs["r_calf"].parentJoint,
					hip: rig.limbs["r_thigh"].parentJoint,
					foot: rig.limbs["r_foot"],
					thigh: rig.limbs["r_thigh"],
					calf: rig.limbs["r_calf"],
					getAnklePos: () => vec2(rig.limbs["r_calf"].body.position).add(vec2(rig.limbs["r_calf"]._endOffset).rotated(rig.limbs["r_calf"].body.rotation)),
					defaultHipAngle: rig.limbs["r_thigh"].parentJoint.getRotation(),
					defaultKneeAngle: rig.limbs["r_calf"].parentJoint.getRotation() / 2,
					ankle: rig.limbs["r_foot"].parentJoint
				};
				this.legL = {
					chain: new IKChain(rig, ["l_thigh", "l_calf"]),
					knee: rig.limbs["l_calf"].parentJoint,
					hip: rig.limbs["l_thigh"].parentJoint,
					foot: rig.limbs["l_foot"],
					thigh: rig.limbs["l_thigh"],
					calf: rig.limbs["l_calf"],
					getAnklePos: () => vec2(rig.limbs["l_calf"].body.position).add(vec2(rig.limbs["l_calf"]._endOffset).rotated(rig.limbs["l_calf"].body.rotation)),
					defaultHipAngle: rig.limbs["l_thigh"].parentJoint.getRotation(),
					defaultKneeAngle: rig.limbs["l_calf"].parentJoint.getRotation() / 2,
					ankle: rig.limbs["l_foot"].parentJoint
				};

				this.legR.chain._drawTargetDebug = true;
				this.legL.chain._drawTargetDebug = true;
				// --------------- arms ---------------
				this.armR = {
					chain: new IKChain(rig, ["r_bicep"]),
					shoulder: rig.limbs["r_bicep"].parentJoint,
					elbow: rig.limbs["r_fore"].parentJoint,
					hand: rig.limbs["r_hand"]
				};
				this.armL = {
					chain: new IKChain(rig, ["l_bicep"]),
					shoulder: rig.limbs["l_bicep"].parentJoint,
					elbow: rig.limbs["l_fore"].parentJoint,
					hand: rig.limbs["l_hand"]
				};

				this.stepLegStartX = 0;
				this.stepClearance = 0;
				this.steppingLeg = null;
				this.supportLeg = null;
				this.lastLegSwitchTime = 0;
				this.isSteppingForward = false;

				//this.armR.chain._drawTargetDebug = true;
				//this.armL.chain._drawTargetDebug = true;

				this.resetMotorTargetAnglesToCurrentAngles();

				this.rig = rig;
			}

			/* --------------------------------------------------------- */
			isGrounded(leg) {
				return leg.foot.isColliding();
			}

			resetMotorTargetAnglesToCurrentAngles() {
				rig.limbs["r_fore"].parentJoint.setMotorTargetAngle(elbowRestAngle, 10, 5, 5, false);
				rig.limbs["l_fore"].parentJoint.setMotorTargetAngle(elbowRestAngle, 10, 5, 5, false);

				// Init all to neutral
				this.legR.hip.setMotorTargetAngle(this.legR.hip.getRotation(), 25, 20, 5, false);
				this.legL.hip.setMotorTargetAngle(this.legL.hip.getRotation(), 25, 20, 5, false);
				this.legR.knee.setMotorTargetAngle(this.legR.knee.getRotation(), 25, 20, 5, false);
				this.legL.knee.setMotorTargetAngle(this.legL.knee.getRotation(), 25, 20, 5, false);

				this.armR.shoulder.setMotorTargetAngle(this.armR.shoulder.getRotation(), 25, 20, 5, false);
				this.armL.shoulder.setMotorTargetAngle(this.armL.shoulder.getRotation(), 25, 20, 5, false);
			}

			feetOnSameSide(comX) {
				const lx = this.legL.getAnklePos().x;
				const rx = this.legR.getAnklePos().x;
				return (lx < comX && rx < comX) ||
					(lx > comX && rx > comX);
			}

			flipAcrossCOM(pos, com, scale = 1) {
				return vec2(pos).sub(com).scale(vec2(-1*scale, 1)).add(com);
			}

			/* --------------------------------------------------------- */
			update(dt) {
				const com = this.rig.getCenterOfMass();
				const onGroundR = this.isGrounded(this.legR);
				const onGroundL = this.isGrounded(this.legL);

				let l_dist_from_com = Math.abs(this.legL.getAnklePos().x - com.x);
				let r_dist_from_com = Math.abs(this.legR.getAnklePos().x - com.x);

				let stepping_leg;
				if (onGroundR === onGroundL) {
					// When on ground fully or in air fully, step with the leg that is further from the center of mass (stepping over to catch the body)
					stepping_leg = l_dist_from_com > r_dist_from_com && Math.abs(l_dist_from_com - r_dist_from_com) > 0.01 ? this.legL : this.legR;
				}
				// One foot on ground, one foot off ground. Needs to take a step
				else {
					stepping_leg = onGroundR ? this.legL : this.legR;
				}

				// Prevent rapidly switching legs
				if (Date.now() - this.lastLegSwitchTime < 200) {
					stepping_leg = this.steppingLeg;
				}

				let support_leg = stepping_leg === this.legR ? this.legL : this.legR;

				let support_leg_arm = support_leg === this.legR ? this.armL : this.armR;
				let stepping_leg_arm = stepping_leg === this.legR ? this.armL : this.armR;

				// Move stepping leg to opposite of support leg, on other side of center of mass using IK
				let step_target = this.flipAcrossCOM(support_leg.getAnklePos(), com);

				if (stepping_leg !== this.steppingLeg) {
					this.steppingLeg = stepping_leg;
					this.supportLeg = support_leg;
					this.stepLegStartX = stepping_leg.getAnklePos().x;
					this.stepClearance = ez.lerpClamp(0.1, 1.0, Math.abs(step_target.x - this.stepLegStartX) / 2.0);
					this.stepStartTime = Date.now();
					this.lastLegSwitchTime = Date.now();
					this.isSteppingForward = step_target.x > this.stepLegStartX;
				}

				if(this.isSteppingForward) {
					step_target = this.flipAcrossCOM(support_leg.getAnklePos(), com, 0.7);
				}
				else {
					step_target = this.flipAcrossCOM(support_leg.getAnklePos(), com, 1.05);
				}

				// Old method:
				const lift_foot_for_clearance = 0.4 * Math.min(1, Math.abs((step_target.x - stepping_leg.getAnklePos().x)) / 1.0); // If it's further from the goal, it needs to raise up the foot so it doesn't hit the ground
				step_target.y += lift_foot_for_clearance;

				// Old method with sin:
				//const lift_foot_for_clearance = 0.4 * Math.sin(Math.PI * Math.min(1, Math.abs((step_target[0] - stepping_leg.getAnklePos()[0])) / 2.0)); // If it's further from the goal, it needs to raise up the foot so it doesn't hit the ground
				//step_target.y += lift_foot_for_clearance;

				const curX = stepping_leg.getAnklePos().x;
				const dstX = step_target.x;
				const span = Math.abs(dstX - this.stepLegStartX) || 1e-6;  // avoid ÷0
				//let swing_progress = Math.abs(curX - this.stepLegStartX) / span;

				//console.log(swing_progress);
				//console.log(this.stepClearance);
				//step_target.y += Math.sin(Math.PI * swing_progress) * 0.5;
				//console.log(swing_progress);
				//console.log(step_target);
				//console.log(stepping_leg.getAnklePos());
				//console.log(support_leg.getAnklePos());
				//console.log(com);

				stepping_leg.chain.solve(step_target);

				// -------------------------
				// Support leg placement attempts
				// -------------------------
				// I think just setting the knee to the default angle makes sense
				support_leg.knee.setMotorTargetAngle(support_leg.defaultKneeAngle, 15, 5, 2, false);

				// Idea: just rotate the supprot leg hip to the default angle. Didn't work that well.
				//support_leg.hip.setMotorTargetAngle(support_leg.defaultHipAngle, 15, 8, 2, false);

				// Idea: Make the support leg hip rotate to the opposite of the stepping leg hip. Didn't seem to work well.
				//support_leg.hip.setMotorTargetAngle(_shortDiff(stepping_leg.hip.motorTargetAngle, Math.PI) * -1 + Math.PI, 12, 4, 2, false);

				// Idea: rotate the support leg hip, to rotate the BODY upright. Calculate the angle of the body, and set the support leg hip to the opposite.
				// This works pretty well. Might be it.
				let bodyAngleFromUp = _shortDiff(Math.PI / 2, this.rig.limbs["pelvis"].body.rotation);
				support_leg.hip.setMotorTargetAngle(support_leg.hip.getRotation() - bodyAngleFromUp, 15, 8, 4, false);
				// -------------------------

				// Move arms to match legs. Right arm follows left leg, left arm follows right leg
				let arm_target_y = this.rig.limbs["pelvis"].body.position.y - 0.5;
				// Idea: Target foot position X of opposite leg
				support_leg_arm.chain.solve(vec2(support_leg.getAnklePos().x, arm_target_y));
				stepping_leg_arm.chain.solve(vec2(stepping_leg.getAnklePos().x, arm_target_y));
				//support_leg_arm.chain.solve(vec2(support_leg.foot.body.position[0], arm_target_y));
				//stepping_leg_arm.chain.solve(vec2(stepping_leg.foot.body.position[0], arm_target_y));
				
				// Idea: Flip opposite leg X position across COM
				//support_leg_arm.chain.solve([this.flipAcrossCOM(support_leg.getAnklePos(), com)[0], arm_target_y]);
				//stepping_leg_arm.chain.solve([this.flipAcrossCOM(step_target, com)[0], arm_target_y]); // Use step target
				//support_leg_arm.chain.solve([this.flipAcrossCOM(support_leg.getAnklePos(), com)[0], arm_target_y]);

				// Idea: IK to step target, predictive. Seems to be a little less stable.
				//support_leg_arm.chain.solve(vec2(support_leg.foot.body.position[0], arm_target_y));
				//stepping_leg_arm.chain.solve(vec2(step_target[0], arm_target_y));

				// Just doing IK on shoulder to simplify, adjust angle IK'd to to match the elbow offset angle
				const bicepLength = 0.95;
				const forearmLength = 1.05;
				let angleOffset = Math.abs(vec2(bicepLength, 0).add(vec2(forearmLength, 0).rotated(elbowRestAngle)).angle());
				this.armR.shoulder.motorTargetAngle -= angleOffset;
				this.armL.shoulder.motorTargetAngle -= angleOffset;

				// Set feet target angle so they are parallel to the ground
				this.legR.ankle.setMotorTargetAngle(-this.legR.calf.body.rotation - 0.042, 2, 12, 2, true);
				this.legL.ankle.setMotorTargetAngle(-this.legL.calf.body.rotation - 0.042, 2, 12, 2, true);

				support_leg.chain.clearDebugDraw();
			}

			/* --------------------------------------------------------- */
			drawDebug() {
				this.legR.chain.drawDebug(ez.ctx, "maroon");
				this.legL.chain.drawDebug(ez.ctx);
				this.armR.chain.drawDebug();
				this.armL.chain.drawDebug();

				ez.circle(vec2(this.legR.getAnklePos()), 0.06).fill("aliceblue");
				ez.circle(vec2(this.legL.getAnklePos()), 0.06).fill("aliceblue");
			}
		}

		// ──────────────────────────────────────────────────────────────
		// Ragdoll State Persistence
		// ──────────────────────────────────────────────────────────────
		function saveRagdollState(rig) {
			if (typeof localStorage === 'undefined') {
				console.warn("localStorage is not available. Cannot save ragdoll state.");
				return;
			}
			const state = {
				limbs: {},
				timeScale: guiControls["Time scale"], // Save time scale
				showDebug: guiControls["Show debug"],  // Save show debug state
				isPaused: physPaused
			};
			for (const name in rig.limbs) {
				const limb = rig.limbs[name];
				const body = limb.body;
				if (!body) continue;

				// Get the color using PhysRenderer
				let color = null;
				if (typeof PhysRenderer !== 'undefined' && PhysRenderer._getObjectColor) {
					color = PhysRenderer._getObjectColor(body);
				}

				state.limbs[name] = {
					position: [body.position.x, body.position.y],
					rotation: body.rotation,
					velocity: [body.velocity.x, body.velocity.y],
					angularVelocity: body.angularVelocity,
					isStatic: body.isStatic, // Save static state for potential freezing
					color: color // Save the color
				};
			}
			try {
				localStorage.setItem('ragdollState', JSON.stringify(state));
				// console.log("Ragdoll state saved."); // For debugging
			} catch (e) {
				console.error("Error saving ragdoll state to localStorage:", e);
			}
		}

		function loadRagdollState(rig) {
			if (typeof localStorage === 'undefined') {
				console.warn("localStorage is not available. Cannot load ragdoll state.");
				return;
			}
			const savedStateJSON = localStorage.getItem('ragdollState');
			if (!savedStateJSON) {
				// console.log("No saved ragdoll state found."); // For debugging
				return;
			}

			try {
				const savedState = JSON.parse(savedStateJSON);
				if (!savedState || !savedState.limbs) {
					console.warn("Invalid saved state format.");
					return;
				}

				// Restore GUI controls
				if (savedState.timeScale !== undefined) {
					guiControls["Time scale"] = savedState.timeScale;
				}
				if (savedState.showDebug !== undefined) {
					guiControls["Show debug"] = savedState.showDebug;
				}
				if (savedState.isPaused !== undefined) { // Restore pause state
					physPaused = savedState.isPaused;
				}

				for (const name in savedState.limbs) {
					if (rig.limbs[name]) {
						const limb = rig.limbs[name];
						const body = limb.body;
						if (!body) continue;

						const limbData = savedState.limbs[name];

						if (limbData.position) body.position = new Vec2(limbData.position[0], limbData.position[1]);
						if (limbData.rotation !== undefined) body.rotation = limbData.rotation;
						if (limbData.velocity) body.velocity = new Vec2(limbData.velocity[0], limbData.velocity[1]);
						if (limbData.angularVelocity !== undefined) body.angularVelocity = limbData.angularVelocity;
						if (limbData.isStatic !== undefined) body.isStatic = limbData.isStatic;


						// Restore the color
						if (limbData.color) {
							if (typeof PhysRenderer !== 'undefined' && PhysRenderer._objectColors && typeof PhysRenderer._objectColors.set === 'function') {
								PhysRenderer._objectColors.set(body, limbData.color);
							} else {
								// console.warn("PhysRenderer or _objectColors not available for setting color on limb:", name); // For debugging
							}
						}
					}
				}
				// console.log("Ragdoll state loaded."); // For debugging
			} catch (e) {
				console.error("Error loading ragdoll state from localStorage:", e);
				// Optionally clear corrupted state: localStorage.removeItem('ragdollState');
			}
		}

		// ──────────────────────────────────────────────────────────────
		// Scene
		// ──────────────────────────────────────────────────────────────
		let rig, ikArm, stepper;
		function setupScene() {
			rig = new Rig(world);

			const pelvis = rig.addLimb("pelvis", "capsule",
				{ y: 1.46, length: 0.55, radiusA: 0.30, radiusB: 0.30, isStatic: false, rotation: Math.PI / 2, zIndex: 2 }
			).limb;

			const mid = rig.addLimb("mid", "capsule",
				{ length: 0.55, radiusA: 0.30, radiusB: 0.30, isStatic: false, rotation: Math.PI / 2, zIndex: 2 },
				"pelvis", { limit: Math.PI / 6 }
			).limb;
			mid.parentJoint.setMotorTargetAngle(0, 200, 100, 15, true);

			const chest = rig.addLimb("chest", "capsule",
				{ length: 0.65, radiusA: 0.3, radiusB: 0.3, isStatic: false, rotation: Math.PI / 2, zIndex: 2 },
				"mid", { limit: Math.PI / 6 }
			).limb;
			chest.parentJoint.setMotorTargetAngle(0, 200, 100, 15, true);

			const neck = rig.addLimb("neck", "capsule",
				{ length: 0.68, radiusA: 0.18, radiusB: 0.18, rotation: Math.PI / 2, zIndex: 1 },
				"chest", { limit: 0 }
			).limb;

			rig.addLimb("head", "circle", { radius: 0.4, zIndex: 2 }, "neck", { limit: 0, center: -Math.PI / 2 });

			const armLim = Math.PI * 1.4;
			const elbowLim = Math.PI * 0.8;

			rig.addLimb("r_bicep", "capsule",
				{ length: 0.95, radiusA: 0.22, radiusB: 0.18, zIndex: 4, rotation: Math.PI * 1.3 },
				"chest", { /*limit: armLim, center: Math.PI */ }
			);
			rig.addLimb("r_fore", "capsule",
				{ length: 1.05, radiusA: 0.18, radiusB: 0.14, zIndex: 4 },
				"r_bicep", { limit: elbowLim, center: elbowLim / 2 }
			);
			rig.addLimb("r_hand", "circle", { radius: 0.21, zIndex: 4 }, "r_fore", { limit: 0 });

			// left arm (mirrored, not IK driven)
			rig.addLimb("l_bicep", "capsule",
				{ length: 0.95, radiusA: 0.22, radiusB: 0.18, zIndex: 0, rotation: Math.PI * 1.7 },
				"chest", { /*limit: armLim, center: Math.PI */ }
			);
			rig.addLimb("l_fore", "capsule",
				{ length: 1.05, radiusA: 0.18, radiusB: 0.14, zIndex: 0 },
				"l_bicep", { limit: elbowLim, center: elbowLim / 2 }
			);
			rig.addLimb("l_hand", "circle", { radius: 0.21, zIndex: 0 }, "l_fore", { limit: 0 });

			const hipR = Math.PI * 0.75;
			const kneeR = Math.PI * 0.8;
			const ankR = Math.PI * 0.65;

			rig.addLimb("r_thigh", "capsule",
				{ length: 1.45, radiusA: 0.3, radiusB: 0.22, zIndex: 3, rotation: Math.PI * 1.6 },
				"pelvis", { anchorA: "start", anchorB: "start", limit: hipR, center: Math.PI }
			);
			rig.addLimb("r_calf", "capsule",
				{ length: 1.45, radiusA: 0.22, radiusB: 0.16, zIndex: 3, rotation: Math.PI * 1.5 },
				"r_thigh", { limit: kneeR, center: -Math.PI / 2 + Math.PI * 0.1 }
			);
			rig.addLimb("r_foot", "capsule",
				{ length: 0.70, radiusA: 0.14, radiusB: 0.10, zIndex: 3, offsetX: 0.05, offsetY: -0.05 },
				"r_calf", { limit: ankR, center: Math.PI / 2 }
			);
			rig.limbs["r_foot"].parentJoint.setMotorTargetAngle(Math.PI * 0.5, 20, 10, 5, true);

			rig.addLimb("l_thigh", "capsule",
				{ length: 1.45, radiusA: 0.3, radiusB: 0.22, zIndex: 1, rotation: Math.PI * 1.4 },
				"pelvis", { anchorA: "start", anchorB: "start", limit: hipR, center: Math.PI }
			);
			rig.addLimb("l_calf", "capsule",
				{ length: 1.45, radiusA: 0.22, radiusB: 0.16, zIndex: 1, rotation: Math.PI * 1.3 },
				"l_thigh", { limit: kneeR, center: -Math.PI / 2 + Math.PI * 0.1 }
			);
			rig.addLimb("l_foot", "capsule",
				{ length: 0.70, radiusA: 0.14, radiusB: 0.10, zIndex: 1, offsetX: 0.05, offsetY: -0.05 },
				"l_calf", { limit: ankR, center: Math.PI / 2 }
			);
			rig.limbs["l_foot"].parentJoint.setMotorTargetAngle(Math.PI * 0.5, 20, 10, 5, true);

			const floor = world.addBox(0, -6, 23, 6, 1, true);
			floor.restitution = 0.0; // Make it easier for ragdoll to walk without bouncing
			floor.friction = 1.0;

			ikArm = new IKChain(rig, ["r_thigh", "r_calf"]);
			stepper = new StepController(rig);
			if (guiControls["Show debug"]) {
				rig.toggleJointLimits(true);
			}
		}


		// ──────────────────────────────────────────────────────────────
		// GUI Controls
		// ──────────────────────────────────────────────────────────────
		let physPaused = false
		let _currentlyShowingDebug = true
		const guiControls = {
			"Show debug": false,
			"Time scale": 1,
			"Reset Simulation [R]": resetSimulation,
			"Pause simulation [Space]": () => physPaused = !physPaused,
			"Freeze [F]": () => {
				let p = rig.limbs["pelvis"].body
				p.isStatic = !p.isStatic;
				if (p.isStatic) {
					p.velocity = new Vec2(0, 0);
					p.angularVelocity = 0;
				}
			},
			_hints: {
				"Time scale": {
					min: 0.01,
					max: 1,
					step: 0.01,
				},
				"Freeze [F]": {
					hidden: true
				},
				"Time scale": {
					hidden: true
				},
				"Pause simulation [Space]": {
					hidden: true
				},
			}
		};

		ez.gui(guiControls, {}, {
			theme: 'minimalist',
			darkMode: (() => {
				const urlParams = new URLSearchParams(window.location.search);
				const theme = urlParams.get('theme');
				return theme !== 'light';
			})(),
			hideControlsButton: true
		});


		// ──────────────────────────────────────────────────────────────
		// Keyboard input (A/D lean)
		// ──────────────────────────────────────────────────────────────
		const input = { left: false, right: false };
		window.addEventListener('keydown', (e) => {
			const k = e.key.toLowerCase();
			if (k === 'a' || k === 'arrowleft') input.left = true;
			if (k === 'd' || k === 'arrowright') input.right = true;
		});
		window.addEventListener('keyup', (e) => {
			const k = e.key.toLowerCase();
			if (k === 'a' || k === 'arrowleft') input.left = false;
			if (k === 'd' || k === 'arrowright') input.right = false;
		});


		// ──────────────────────────────────────────────────────────────
		// Main loop
		// ──────────────────────────────────────────────────────────────
		function update(dt) {
			ez.clear();
			ez.ctx.lineWidth = 1;
			ez.grid(1, 50).stroke(0xbbbbbb);
			ez.ctx.lineWidth = 1.5;
			//ez.line(vec2(0, -1000), vec2(1000, 0)).stroke("grey");
			//ez.line(vec2(-1000, 0), vec2(1000, 0)).stroke("grey");

			PhysRenderer.render(world);
			//ikArm.solve(ez.getMousePosWorld());
			//ikArm.drawDebug();

			stepper.update(dt * guiControls["Time scale"]);

			// Apply a small horizontal impulse at the chest to encourage leaning
			const simDt = dt * guiControls["Time scale"];
			const horiz = (input.right ? 1 : 0) - (input.left ? 1 : 0);
			if (horiz !== 0) {
				const chestLimb = rig.limbs["chest"];
				if (chestLimb) {
					const pushN = 65; // tuning value for walking urge
					const impulse = new Vec2(horiz * pushN * simDt, 0);
					const applyAt = chestLimb.getWorldAnchor("end");
					chestLimb.body.applyImpulse(impulse, applyAt);
				}
			}
			if (!physPaused) {
				world.step(dt * guiControls["Time scale"], fixedDt, maxSubstepsPerFrame);
			}

			// Check if ragdoll has fallen too far and reset if needed
			const com = rig.getCenterOfMass();
			if (com.y < -10) {
				resetSimulation();
			}

			// Save state continuously (can be optimized)
			saveRagdollState(rig);

			if (guiControls["Show debug"]) {
				// Draw center of mass
				const com = rig.getCenterOfMass();
				ez.circle([com.x, groundY], 0.075).fill("rgba(0, 255, 0, 0.5)"); // Green semi-transparent circle
				//ez.line(vec2(com[0], -1000), vec2(com[0], 1000)).stroke("rgba(0, 255, 0, 0.5)");
				stepper.drawDebug();
			}
			if (guiControls["Show debug"] && !_currentlyShowingDebug) {
				rig.toggleJointLimits(true);
				//PhysRenderer._renderConstraints = true;
				_currentlyShowingDebug = true;
			}
			else if (!guiControls["Show debug"] && _currentlyShowingDebug) {
				rig.toggleJointLimits(false);
				//PhysRenderer._renderConstraints = false;
				_currentlyShowingDebug = false;
			}
		}

		// Force-clear any saved ragdoll state on load (temporary recovery for hard-locked state)
		(() => {
			if (typeof localStorage !== 'undefined') {
				try {
					//localStorage.removeItem('ragdollState');
				} catch (e) {
					console.warn("Unable to clear ragdollState from localStorage on load:", e);
				}
			}
		})();
		
		setupScene();
		// Load state immediately after setup
		loadRagdollState(rig);

		world.constraintIterations = 25;
		PhysRenderer.initMouseControls(world);
		ez.callAnimate(update, true);
	</script>
</body>

</html>