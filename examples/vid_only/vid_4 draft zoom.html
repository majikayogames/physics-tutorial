<!DOCTYPE html>
<html>
<head>
    <title>Collision Detection & Contact Generation Explained</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@400;600&display=swap">
</head>
<body>
    <script src="../ezdraw.js"></script>
    <script src="../../simple_phys.js"></script>
    <script src="../simple_phys_mixed_verlet.js"></script>
    <script src="../simple_phys_ezdraw_renderer.js"></script>
    <script src="../curtain_intro.js"></script>
    <script src="../slime-renderer-mixed.js"></script>
    <script src="../mixed_slime.js"></script>
    <script>
        // Seeded random number generator for deterministic demos
        let DEMO_SEED; // Decent stack
        DEMO_SEED = 836432; // Decent stack
        DEMO_SEED = 795417; // Decent stack, words not too obstructed
        DEMO_SEED = 929962; // Decent scatter, words not too obstructed
        DEMO_SEED = 692193; // Decent shape
        DEMO_SEED = 425736; // Decent shape no slime control needed he just falls
        //DEMO_SEED = undefined; // Comment this line to use the seed above
        
        let rngSeed = DEMO_SEED !== undefined ? DEMO_SEED : Math.floor(Math.random() * 1000000);
        console.log(`Demo seed: ${rngSeed}`);
        
        // Simple seeded RNG using mulberry32
        function seededRandom() {
            let t = rngSeed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        
        const canvas = ez.createCanvasAndAddToPage();
        // Ensure white page background behind transparent canvas and SVG
        document.body.style.background = '#ffffff';
        // SVG overlay for jitter-free text (grid handled via ez.gridSvg)
        const SVG_NS = "http://www.w3.org/2000/svg";
        let svg, gTextScreen, svgTitle, svgSubtitle;
        function setupSvgTextOverlay() {
            // Ensure grid overlay exists (and its SVG) via ez.gridSvg
            ez.gridSvg(1, Infinity);
            svg = ez._svgGridOverlay?.svg;
            if (!svg) return;

            // Reuse or create defs for shadows
            let defs = svg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS(SVG_NS, 'defs');
                svg.appendChild(defs);
            }
            let shadowTitle = defs.querySelector('#shadowTitle');
            if (!shadowTitle) {
                shadowTitle = document.createElementNS(SVG_NS, 'filter');
                shadowTitle.setAttribute('id', 'shadowTitle');
                const feDrop1 = document.createElementNS(SVG_NS, 'feDropShadow');
                feDrop1.setAttribute('dx', '0');
                feDrop1.setAttribute('dy', '0');
                feDrop1.setAttribute('stdDeviation', '2');
                feDrop1.setAttribute('flood-color', '#000000');
                feDrop1.setAttribute('flood-opacity', '0.25');
                shadowTitle.appendChild(feDrop1);
                defs.appendChild(shadowTitle);
            }
            let shadowSub = defs.querySelector('#shadowSub');
            if (!shadowSub) {
                shadowSub = document.createElementNS(SVG_NS, 'filter');
                shadowSub.setAttribute('id', 'shadowSub');
                const feDrop2 = document.createElementNS(SVG_NS, 'feDropShadow');
                feDrop2.setAttribute('dx', '0');
                feDrop2.setAttribute('dy', '0');
                feDrop2.setAttribute('stdDeviation', '1.5');
                feDrop2.setAttribute('flood-color', '#000000');
                feDrop2.setAttribute('flood-opacity', '0.2');
                shadowSub.appendChild(feDrop2);
                defs.appendChild(shadowSub);
            }

            // Screen-space text group (avoid vertical flip from camera)
            gTextScreen = document.createElementNS(SVG_NS, 'g');
            gTextScreen.setAttribute('fill', '#000');
            svg.appendChild(gTextScreen);

            svgTitle = document.createElementNS(SVG_NS, 'text');
            svgTitle.setAttribute('text-anchor', 'middle');
            svgTitle.setAttribute('dominant-baseline', 'middle');
            svgTitle.setAttribute('font-family', "'Source Sans Pro', sans-serif");
            svgTitle.setAttribute('font-weight', '700');
            svgTitle.setAttribute('filter', 'url(#shadowTitle)');
            gTextScreen.appendChild(svgTitle);

            svgSubtitle = document.createElementNS(SVG_NS, 'text');
            svgSubtitle.setAttribute('text-anchor', 'middle');
            svgSubtitle.setAttribute('dominant-baseline', 'middle');
            svgSubtitle.setAttribute('font-family', "'Source Sans Pro', sans-serif");
            svgSubtitle.setAttribute('filter', 'url(#shadowSub)');
            gTextScreen.appendChild(svgSubtitle);
        }
        setupSvgTextOverlay();
        ez.centerOrigin = true;

        const worldHeight = 16;
        const cameraCenterY = -0.8;
        let worldWidth;

        function updateCamera() {
            const aspect = canvas.width / canvas.height;
            worldWidth = worldHeight * aspect;
            ez.letterBoxCamera(vec2(0, cameraCenterY), vec2(worldWidth, worldHeight), true);
        }

        updateCamera();
        
        // Smooth zoom-out camera that keeps bottom-left anchored
        let zoomTimer = 0;
        let zoomDelay = 5.0; // delay before starting zoom (seconds)
        const zoomDuration = 8.0; // seconds
        const zoomStart = 0.5; // start 2x zoomed IN (smaller view size)
        const zoomEnd = 1.0;   // end at original view (1x)
        let baseBottomLeft = null; // world-space anchor for bottom-left

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function initCameraAnchor() {
            const aspect = canvas.width / canvas.height;
            const baseWidth = worldHeight * aspect;
            baseBottomLeft = vec2(-baseWidth * 0.5, cameraCenterY - worldHeight * 0.5);
        }

        function applyCamera(dt) {
            if (baseBottomLeft === null) initCameraAnchor();
            // Wait until delay elapses, then advance zoom timer until target
            if (zoomDelay > 0) {
                zoomDelay = Math.max(0, zoomDelay - dt);
            } else if (zoomTimer < zoomDuration) {
                zoomTimer = Math.min(zoomDuration, zoomTimer + dt);
            }
            const t = easeInOutCubic(zoomTimer / zoomDuration);
            const zoom = zoomStart + (zoomEnd - zoomStart) * t;

            const aspect = canvas.width / canvas.height;
            const viewHeight = worldHeight * zoom;
            const viewWidth = viewHeight * aspect;

            // Keep bottom-left fixed at baseBottomLeft as we zoom
            const centerX = baseBottomLeft.x + viewWidth * 0.5;
            const centerY = baseBottomLeft.y + viewHeight * 0.5;

            ez.letterBoxCamera(vec2(centerX, centerY), vec2(viewWidth, viewHeight), true);
        }

        function updateSvgFromCamera() {
            if (!svg) return;
            // Update text in screen-space to avoid vertical flipping; compute screen positions and pixel font sizes
            const titleWorldPos = vec2(0, cameraCenterY + 2.25);
            const subWorldPos = vec2(0, cameraCenterY + 0.3);
            const titleScreen = ez.worldToScreen(vec3(titleWorldPos.x, titleWorldPos.y, 0));
            const subScreen = ez.worldToScreen(vec3(subWorldPos.x, subWorldPos.y, 0));
            // Match ez.textWorldScaled scaling: fontSize / yScale * 0.1, where yScale = |camera.col2|
            const yScale = Math.hypot(ez.camera.matrix.col2.x, ez.camera.matrix.col2.y);
            const titleSizePx = (12.8 / yScale) * 0.1;
            const subSizePx = (3.2 / yScale) * 0.1;

            // Title (multi-line) â€“ match ez.text baseline math
            svgTitle.setAttribute('x', String(titleScreen.x));
            while (svgTitle.firstChild) svgTitle.removeChild(svgTitle.firstChild);
            svgTitle.setAttribute('font-size', String(titleSizePx));
            const titleLines = ["Collision Detection & Contact Generation", "Explained"];
            const lineHeight = titleSizePx * 1.2;
            const totalHeight = titleLines.length * lineHeight;
            const startY = titleScreen.y - totalHeight / 2 + lineHeight / 2;
            for (let i = 0; i < titleLines.length; i++) {
                const tspan = document.createElementNS(SVG_NS, 'tspan');
                tspan.setAttribute('x', String(titleScreen.x));
                tspan.setAttribute('y', String(startY + i * lineHeight));
                tspan.setAttribute('dominant-baseline', 'middle');
                tspan.textContent = titleLines[i];
                svgTitle.appendChild(tspan);
            }

            // Subtitle (single line)
            svgSubtitle.setAttribute('x', String(subScreen.x));
            svgSubtitle.setAttribute('y', String(subScreen.y));
            svgSubtitle.setAttribute('font-size', String(subSizePx));
            svgSubtitle.textContent = "Part of the physics engine tutorial series created by Majikayo Games";
        }

        initCameraAnchor();
        window.addEventListener('resize', () => { applyCamera(0); ez.gridSvg(1, Infinity); updateSvgFromCamera(); });

        const world = new PhysWorldMixed();
        world.gravity = new Vec2(0, -9.81);

        const groundY = cameraCenterY - worldHeight / 2 + 0.5;
        world.addBox(0, groundY, worldWidth + 2, 1, 1, true);

        const permanentContacts = [];
        let activeFallers = 0;

        PhysRenderer._renderConstraints = false;

        function freezeOnContact() {
            if (activeFallers === 0) return;
            for (const c of world.constraints) {
                if (!(c instanceof ContactConstraint)) continue;
                const bodies = [c.bodyA, c.bodyB];
                for (const body of bodies) {
                    if (body._falling && !body._frozen) {
                        // Only freeze when contacting a static (ground or already-frozen) body
                        const other = body === c.bodyA ? c.bodyB : c.bodyA;
                        if (!other.isStatic) continue;
                        const local = body === c.bodyA ? c.localA : c.localB;
                        const wp = body.localToWorld(local);
                        permanentContacts.push({ x: wp.x, y: wp.y });
                        const color = PhysRenderer._getObjectColor(body);
                        body._renderColorHint = color;
                        PhysRenderer._objectColors.set(body, color);
                        body.isStatic = true;
                        body.velocity = new Vec2(0, 0);
                        body.angularVelocity = 0;
                        body._frozen = true;
                        body._falling = false;
                        activeFallers--;
                    }
                }
            }
        }

        world.onDetectCollisions = freezeOnContact;

        function addStar(world, x, y, points, outerRadius, innerRadius, angleOffset = 0) {
            const shapes = [];
            const triangles = [];
            const step = (Math.PI * 2) / points;

            const outer = [];
            const inner = [];

            for (let k = 0; k < points; k++) {
                const angleOuter = angleOffset + k * step;
                const angleInner = angleOuter + step / 2;

                outer.push(new Vec2(outerRadius * Math.cos(angleOuter), outerRadius * Math.sin(angleOuter)));
                inner.push(new Vec2(innerRadius * Math.cos(angleInner), innerRadius * Math.sin(angleInner)));
            }

            for (let k = 0; k < points; k++) {
                const O = outer[k];
                const I = inner[k];
                const Op = outer[(k + 1) % points];

                shapes.push(new ConvexPolygonShape([new Vec2(0, 0), O, I]));
                shapes.push(new ConvexPolygonShape([new Vec2(0, 0), I, Op]));

                triangles.push({ v1: O, v2: I });
                triangles.push({ v1: I, v2: Op });
            }

            let totalArea = 0;
            for (const tri of triangles) {
                const x1 = tri.v1.x, y1 = tri.v1.y;
                const x2 = tri.v2.x, y2 = tri.v2.y;
                totalArea += Math.abs(x1 * y2 - x2 * y1) * 0.5;
            }
            const density = 1 / totalArea;

            let momentOfInertia = 0;
            for (const tri of triangles) {
                const x1 = tri.v1.x, y1 = tri.v1.y;
                const x2 = tri.v2.x, y2 = tri.v2.y;
                const areaTri = Math.abs(x1 * y2 - x2 * y1) * 0.5;
                const mTri = density * areaTri;
                const dot = x1 * x2 + y1 * y2;
                const sum =
                    (x1 * x1 + y1 * y1) +
                    dot +
                    (x2 * x2 + y2 * y2);
                momentOfInertia += (mTri * sum) / 6;
            }

            const star = new PhysObject(x, y, shapes, false, 1, momentOfInertia);
            world.objects.push(star);
            return star;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        const baseOrder = ["star", "capsule", "circle", "box"];
        let shapeOrder = [];

        function nextShapeType() {
            if (shapeOrder.length === 0) {
                shapeOrder = shuffle([...baseOrder]);
            }
            return shapeOrder.pop();
        }

        // Sample from a normal distribution using Box-Muller transform
        function gaussianRandom(mean = 0, stdDev = 1) {
            let u = 0, v = 0;
            while (u === 0) u = seededRandom();
            while (v === 0) v = seededRandom();
            const mag = Math.sqrt(-2.0 * Math.log(u));
            const z = mag * Math.cos(2.0 * Math.PI * v); // N(0,1)
            return mean + z * stdDev;
        }

        function spawnShape() {
            // New strategy: build a center mound by targeting near-center early,
            // then gradually widening targets to form a stable slope
            const left = -worldWidth / 2;
            const right = worldWidth / 2;
            const top = cameraCenterY + worldHeight / 2;
            const margin = 0.6;

            // Much wider spread for a platform-like base
            const progress = Math.min(1, spawnCount / Math.max(1, maxSpawn - 1));
            const baseSigma = worldWidth * 0.15;
            const wideSigma = worldWidth * 0.25;
            const sigma = baseSigma * (1 - progress) + wideSigma * progress;

            // Target across a wide band, truncated to screen with margin
            let xTarget = gaussianRandom(0, sigma);
            xTarget = Math.max(left + margin, Math.min(right - margin, xTarget));

            // Spawn from a wider area above with more horizontal spread, always off-screen
            const x = xTarget + gaussianRandom(0, worldWidth * 0.08);
            const y = top + 2.0 + seededRandom() * 1.0;
            let obj;
            const type = nextShapeType();
            if (type === "box") {
                const w = 1.2 + seededRandom() * 1.6;
                const h = 1.2 + seededRandom() * 1.6;
                obj = world.addBox(x, y, w, h, 1);
            } else if (type === "circle") {
                const r = 0.8 + seededRandom() * 1.2;
                obj = world.addCircle(x, y, r, 1);
            } else if (type === "capsule") {
                const length = 2 + seededRandom() * 3;
                const r1 = 0.4 + seededRandom() * 0.6;
                const r2 = 0.4 + seededRandom() * 0.6;
                obj = world.addCapsule(x, y, length, r1, r2, 1);
            } else {
                const points = 5 + Math.floor(seededRandom() * 3);
                const outer = 1.0 + seededRandom() * 1.5;
                const inner = outer * 0.5;
                obj = addStar(world, x, y, points, outer, inner, seededRandom() * Math.PI * 2);
            }
            // Throw downwards toward the target with stronger speed and small randomness
            const toTarget = new Vec2(xTarget - x, (groundY) - y);
            const dist = Math.max(0.001, toTarget.length());
            let dirVec = toTarget.scale(1 / dist);
            dirVec = new Vec2(dirVec.x, dirVec.y - 0.12).normalized();
            const baseSpeed = 10.5 + seededRandom() * 3.5;
            let vx = dirVec.x * baseSpeed + gaussianRandom(0, 0.35);
            let vy = dirVec.y * baseSpeed + gaussianRandom(0, 0.3);
            // Ensure it's heading downward mostly
            if (vy > -1.0) vy -= 1.2 + seededRandom() * 0.6;
            obj.velocity = new Vec2(vx, vy);
            obj.angularVelocity = (seededRandom() - 0.5) * 4.0;
            obj.friction = 0.85;
            obj.restitution = 0;
            obj._falling = true;
            activeFallers++;
        }

        let spawnTimer = 0;
        const spawnInterval = 0.6;
        const spawnDelay = 3.0;
        let spawnCount = 0;
        const maxSpawn = 15;
        let slime = null;
        let slimeRenderer = null;

        function update(dt) {
            // Apply smooth zoom-out camera first so all rendering uses updated view
            applyCamera(dt);
            // Update SVG grid via library helper and then update text overlay
            ez.gridSvg(1, Infinity, {strokeWidth: 1});
            updateSvgFromCamera();
            spawnTimer += dt;
            if (spawnCount < maxSpawn) {
                const interval = spawnCount === 0 ? spawnDelay : spawnInterval;
                if (spawnTimer >= interval) {
                    spawnShape();
                    spawnCount++;
                    spawnTimer = 0;
                }
            } else if (!slime && activeFallers === 0) {
                const top = cameraCenterY + worldHeight / 2;
                slimeRenderer = new MixedSlimeRenderer(ez);
                document.body.appendChild(slimeRenderer.mainSVG);
                slime = new MixedSlime(world, slimeRenderer, 0, top + 2, { radius: 2, groundAccel: 0.1, airAccel: 0.02, maxHorizSpeed: 1.6 });
            }

            if (slime) slime.preStep(dt);
            world.step(dt, 1 / 544, 40);
            freezeOnContact();

            ez.clear();
            // Grid and titles moved to SVG for jitter-free scaling
            // ez.ctx.lineWidth = 1;
            // ez.grid(1, Infinity).stroke(0xbbbbbb);
            // ez.ctx.lineWidth = 1.5;

            // Title now drawn via SVG

            // Subtitle now drawn via SVG

            PhysRenderer.render(world);
            for (const p of permanentContacts) {
                ez.circle(vec2(p.x, p.y), 0.04).fillAndStroke("#FF6B6B44", PhysRenderer.colors.outline);
            }
            if (slime) slime.render();
        }

        playCurtainIntro(canvas);
        ez.callAnimate(update, true);
    </script>
</body>
</html>
