<!DOCTYPE html>
<html>

<head>
  <title>Effect of torque when applying force to particles and springs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@400;600&display=swap">
</head>

<body>
  <script src="ezdraw.js"></script>
  <script>
    // Basic version of simple_phys just for particles
    class Vec2 {
      constructor(x, y) { this.x = x; this.y = y; }
      add(other) { return new Vec2(this.x + other.x, this.y + other.y); }
      sub(other) { return new Vec2(this.x - other.x, this.y - other.y); }
      scale(scalar) { return new Vec2(this.x * scalar, this.y * scalar); }
      dot(other) { return this.x * other.x + this.y * other.y; }
      cross(other) { return this.x * other.y - this.y * other.x; }
      crossSv(scalar) { return new Vec2(-this.y * scalar, this.x * scalar); }
      length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalized() { return (Math.abs(this.x) < 0.000000001 && Math.abs(this.y) < 0.000000001) ? new Vec2(1, 0) : this.scale(1 / this.length()); }
      rotate(angle) { const cos = Math.cos(angle); const sin = Math.sin(angle); return new Vec2(this.x * cos - this.y * sin, this.x * sin + this.y * cos); }
      rotate90CCW() { return new Vec2(-this.y, this.x); }
      min(other) { return new Vec2(Math.min(this.x, other.x), Math.min(this.y, other.y)); }
      max(other) { return new Vec2(Math.max(this.x, other.x), Math.max(this.y, other.y)); }
    }

    class PhysObject {
      constructor(x, y, mass) {
        this.position = new Vec2(x, y);
        this.velocity = new Vec2(0, 0);
        this.mass = mass;
        this.force = new Vec2(0, 0);
      }

      addForce(f) {
        this.force = this.force.add(f);
      }

      step(dt) {
        // Apply force-based physics: F = ma, so a = F/m
        const acceleration = this.force.scale(1 / this.mass);
        this.velocity = this.velocity.add(acceleration.scale(dt));
        this.position = this.position.add(this.velocity.scale(dt));
      }

      applyImpulse(impulse) {
        this.velocity = this.velocity.add(impulse.scale(1 / this.mass));
      }
    }

    class SpringConstraint {
      constructor(objA, objB, restLength, stiffness = 50, damping = 0) {
        this.objA = objA;
        this.objB = objB;
        this.restLength = restLength;
        this.stiffness = stiffness;
        this.damping = damping;
      }

      solve(dt) {
        const delta = this.objA.position.sub(this.objB.position);
        const currentLength = delta.length();
        
        if (currentLength < 0.0001) return; // Avoid division by zero
        
        const displacement = currentLength - this.restLength;
        const direction = delta.scale(1 / currentLength); // normalized direction
        
        // Spring force: F = -k * displacement
        const springForce = direction.scale(-this.stiffness * displacement);
        
        // Damping force: F = -c * relative_velocity
        const relativeVelocity = this.objA.velocity.sub(this.objB.velocity);
        const dampingForce = direction.scale(-this.damping * direction.dot(relativeVelocity));
        
        // Total force
        const totalForce = springForce.add(dampingForce);
        
        // Apply forces (F = ma, so impulse = F * dt)
        const impulseA = totalForce.scale(dt);
        const impulseB = totalForce.scale(-dt);
        
        this.objA.applyImpulse(impulseA);
        this.objB.applyImpulse(impulseB);
      }
    }

    class CenterConstraint {
      constructor(objA, objB, centerPosition) {
        this.objA = objA;
        this.objB = objB;
        this.centerPosition = centerPosition;
      }

      solve(dt) {
        // Only constrain velocity - keep center of mass velocity at zero
        const currentCenterVel = this.objA.velocity.add(this.objB.velocity).scale(0.5);
        const velCorrection = currentCenterVel.scale(-0.5);
        
        this.objA.velocity = this.objA.velocity.add(velCorrection);
        this.objB.velocity = this.objB.velocity.add(velCorrection);
      }
    }

    class PhysWorld {
      constructor() {
        this.objects = [];
        this.constraints = [];
        this.gravity = new Vec2(0, -9.81);
      }

      step(dt) {
        const substeps = 40;
        const dtSubstep = dt / substeps;

        for (let k = 0; k < substeps; ++k) {
          for (const c of this.constraints) c.solve(dtSubstep);
          for (const obj of this.objects) obj.step(dtSubstep);
        }
        
        // Clear forces after each step
        for (const obj of this.objects) {
          obj.force = new Vec2(0, 0);
        }
      }
    }
  </script>
  <script>
    // Setup canvas with proper scaling (y is up, 100px = 1 unit)
    let canvas = ez.createCanvasAndAddToPage()
    ez.centerOrigin = true
    ez.letterBoxCamera(vec2(0, 0), vec2(8, 4), true)

    // --- Simulation State ---
    let world, objC, objD;
    let timePassed, sleepPhase, forceApplicationPhase, forceStartTime;
    let pathPoints, trailCounter, rampRemainingSteps, accumulator;

    function setupSimulation() {
      world = new PhysWorld();
      objC = new PhysObject(0, 1, 1);
      objD = new PhysObject(0, 0, 1);
      objD.mass = Infinity; // Make bottom particle static
      world.objects.push(objC);
      world.objects.push(objD);
      world.constraints.push(new SpringConstraint(objC, objD, 1));

      // Reset timing and state
      timePassed = 0;
      sleepPhase = true;
      forceApplicationPhase = false;
      forceStartTime = 0;
      rampRemainingSteps = 0;
      pathPoints = [];
      trailCounter = 0;
      accumulator = 0; // Reset time accumulator

      // Set initial spring stiffness based on controls
      if (controls["Stiffness Ramp Time"] > 0) {
        world.constraints[0].stiffness = controls["Spring Stiffness"] * 0.1; // Start at 1/10 stiffness
      } else {
        world.constraints[0].stiffness = controls["Spring Stiffness"]; // Immediate full stiffness
      }
    }
    
    function resetBarbells() {
      setupSimulation();
    }

    function drawPhysWorld(world) {
      for (const obj of world.objects) {
        if (obj.mass === Infinity) {
          // Draw static particle like the old center constraint indicator
          ez.circle(obj.position, 0.12).fillAndStroke("white", "black", 2);
          ez.circle(obj.position, 0.04).fill("black");
        } else {
          // Draw moving particle
          ez.circle(obj.position, 0.1).fill("black");
        }
      }
      for (const constraint of world.constraints) {
        drawSpring(constraint.objA.position, constraint.objB.position);
      }
    }

    function drawSpring(posA, posB) {
      const delta = posB.sub(posA);
      const length = delta.length();
      const direction = delta.normalized();
      const perpendicular = direction.rotate90CCW();
      
      const numCoils = 10;
      const amplitude = 0.15;
      const flatEndLength = 0.2; // Length of flat ends
      
      // Calculate positions for flat ends and coiled middle section
      const flatEndA = posA.add(direction.scale(flatEndLength));
      const flatEndB = posB.sub(direction.scale(flatEndLength));
      const coilLength = length - 2 * flatEndLength;
      
      const points = [];
      
      // Start with connection point A
      points.push(posA);
      
      // Add flat end at A
      points.push(flatEndA);
      
      // Add zigzag coils in the middle section
      for (let i = 1; i < numCoils; i++) {
        const t = i / numCoils;
        const basePos = flatEndA.add(direction.scale(t * coilLength));
        const offset = perpendicular.scale(amplitude * (i % 2 === 0 ? 1 : -1));
        points.push(basePos.add(offset));
      }
      
      // Add flat end at B
      points.push(flatEndB);
      
      // End with connection point B
      points.push(posB);
      
      // Draw lines connecting all points
      for (let i = 0; i < points.length - 1; i++) {
        ez.line(points[i], points[i + 1]).stroke("black");
      }
    }

    // Fixed timestep settings
    const FIXED_DT = 1 / 240;          // Physics step = 240 Hz
    const MAX_SUBSTEPS = 10;           // Clamp work per animation frame, increased from 4

    // Configurable durations
    const sleepDuration = 1.0; // seconds - adjust this value as needed
    const forceApplicationDuration = 1.0; // seconds - adjust this value as needed
    const fadeTime = 6.2; // Fade time for the trail (seconds until a point fully fades)
    
    // Calculate forces needed to deliver same energy as original impulses
    // Original impulses: objC = 1, objD = 1
    // To get same impulse over time: Force = Impulse / Duration
    const forceCD = 1.0 / forceApplicationDuration; // 1 N for 1 second = 1 N⋅s impulse

    // --- GUI controls ---
    const controls = {
      //"Spring Stiffness": 3.14159,
      "Spring Stiffness": 50,
      "Stiffness Ramp Time": 1,
      "Reset [R]": () => {
        resetBarbells();
      },
      "_hints": {
        "Spring Stiffness": {
          "min": 1,
          "max": 500,
          "step": 1
        },
        "Stiffness Ramp Time": {
          "min": 0,
          "max": 2,
          "step": 0.1
        },
        "Reset [R]": {
          "hidden": true
        }
      }
    };
    let showOscillations = false;
    
    ez.gui(controls, {
      "Spring Stiffness": val => {
        // Update spring stiffness immediately if not ramping or ramp time is 0
        if (controls["Stiffness Ramp Time"] === 0 || rampRemainingSteps === 0) {
          world.constraints[0].stiffness = controls["Spring Stiffness"];
        }
        // If we're currently ramping, the ramp logic will pick up the new target value
      },
      "Stiffness Ramp Time": val => {
        // No need to store in separate variable, just use controls directly
      }
    }, {
      theme: 'minimalist',
      darkMode: (() => {
        // Get theme from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const theme = urlParams.get('theme');
        return theme !== 'light';
      })(),
      hideControlsButton: true
    });

    function simulationStep(fixedDt) {
      // Automatic demo reset
      if (timePassed >= 16) {
        setupSimulation();
        return; // Exit this step, setup has reset state.
      }
      internalStep(fixedDt);
    }
    
    // Main animation loop function
    function animationLoop(dt) {
      // This function is called by ez.callAnimate, and it orchestrates the simulation steps and drawing.
      // It maintains the accumulator, which is now local to this scope.
      
      // Clamp dt to prevent "spiral of death" if tabbed away for a long time
      dt = Math.min(dt, 0.1);

      // Accumulate real time and run the physics in fixed-size steps
      accumulator += dt;
      let substeps = 0;
      
      while (accumulator >= FIXED_DT && substeps < MAX_SUBSTEPS) {
        simulationStep(FIXED_DT);
        accumulator -= FIXED_DT;
        substeps++;
      }

      // --- All drawing happens here ---
      draw();
    }

    // All simulation logic happens here, in fixed timesteps
    function internalStep(fixedDt) {
      // Phase transitions (sleep → force application → done)
      if (sleepPhase && timePassed >= sleepDuration) {
        sleepPhase = false;
        forceApplicationPhase = true;
        forceStartTime = timePassed;
        
        // Start stiffness ramp when force application begins (if ramp time > 0)
        if (controls["Stiffness Ramp Time"] > 0) {
          rampRemainingSteps = Math.ceil(controls["Stiffness Ramp Time"] / fixedDt); // Total steps for ramp
        }
      }
      if (forceApplicationPhase && (timePassed - forceStartTime) >= forceApplicationDuration) {
        forceApplicationPhase = false;
      }

      // External forces for this physics step
      if (forceApplicationPhase) {
        objC.addForce(new Vec2(forceCD, 0));
      }

      // Handle stiffness ramping
      if (rampRemainingSteps > 0) {
        // Still ramping - maintain 1/10 stiffness
        world.constraints[0].stiffness = controls["Spring Stiffness"] * 0.1;
        rampRemainingSteps--; // Countdown each physics step
      } else if (controls["Stiffness Ramp Time"] > 0) {
        // Ramp complete - use full stiffness
        world.constraints[0].stiffness = controls["Spring Stiffness"];
      } else {
        // No ramping - use full stiffness immediately
        world.constraints[0].stiffness = controls["Spring Stiffness"];
      }

      // Step physics world at fixed dt
      world.step(fixedDt);

      // Store path points for particle trail (only every 3rd step to reduce lag)
      trailCounter++;
      if (trailCounter >= 3) {
        pathPoints.push({ pos: vec2(objC.position.x, objC.position.y), alpha: 1.0 });
        trailCounter = 0;
      }
      if (pathPoints.length > 800) pathPoints.shift();

      // Fade the trail based on simulation time for deterministic appearance
      for (let i = pathPoints.length - 1; i >= 0; i--) {
        pathPoints[i].alpha -= fixedDt / fadeTime;
        if (pathPoints[i].alpha <= 0) pathPoints.splice(i, 1);
      }

      // Advance simulation time
      timePassed += fixedDt;
    }

    // --- All drawing logic, no state changes ---
    function draw() {
      ez.clear()

      // Draw grid for reference
      ez.ctx.lineWidth = 1
      ez.grid(1, 50).stroke(0xbbbbbb)

      // Draw particle trail
      if (pathPoints.length > 1) {
        for (let i = 0; i < pathPoints.length - 1; i++) {
          const a = Math.min(pathPoints[i].alpha, pathPoints[i + 1].alpha);
          ez.line(pathPoints[i].pos, pathPoints[i + 1].pos).stroke("#0077cc", { lineWidth: 2, globalAlpha: a });
        }
      }

      // Draw subtle circle showing spring rest length
      const restLength = world.constraints[0].restLength;
      if (restLength > 0.01) {
        ez.circle(objD.position, restLength).stroke("#aaaaaaaa", { lineWidth: 1 });
      }

      // Draw physics world
      drawPhysWorld(world);

      // Draw UI text and overlays
      drawInfoText();
      
      // Draw force arrow if in that phase
      if(forceApplicationPhase && (timePassed - forceStartTime) < forceApplicationDuration) {
        drawForceArrow();
      }
    }
    
    function drawForceArrow() {
      const arrowStartC = objC.position.sub(new Vec2(1.2, 0));
      const arrowEndC = objC.position.sub(new Vec2(0.2, 0));
      ez.arrow(arrowStartC, arrowEndC, 15).stroke("black");
      ez.text(`Force of ${forceCD.toFixed(1)}N`, arrowStartC.add(new Vec2(-0.5, 0.3)), {
        fontFamily: "'Source Sans Pro', sans-serif",
        fontSize: 14,
        textAlign: "left",
        textBaseline: "middle",
        fontStyle: "500"
      }).fill("black");
    }

    function drawInfoText() {
      // Calculate kinetic energy for the moving particle
      const energyC = 0.5 * objC.mass * objC.velocity.length() * objC.velocity.length();
      const speedC = objC.velocity.length();
      
      // Calculate spring energy (potential energy stored in spring)
      const springLength = objC.position.sub(objD.position).length();
      const springDisplacement = springLength - world.constraints[0].restLength;
      const springEnergy = 0.5 * world.constraints[0].stiffness * springDisplacement * springDisplacement;

      // Calculate angular velocity around the static pivot (objD)
      const rVec = objC.position.sub(objD.position);
      let angVel = rVec.length() > 1e-6 ? rVec.cross(objC.velocity) / (rVec.length() * rVec.length()) : 0;

      // Display energy, linear velocity and angular velocity values using ez.text with nice font styling
      const textOptions = {
        fontFamily: "'Source Sans Pro', sans-serif",
        fontSize: 18,
        textAlign: "center",
        textBaseline: "middle",
        fontStyle: "500"  // Semi-bold
      };

      // Cheat for clarity. If simulation was accurate, should land at specific rotation speed
      if(Math.abs(angVel - -1.0) < 0.05) angVel = -1
      
      // Round velocity values for clarity
      let displaySpeedC = speedC;
      if(speedC >= 0.95 && speedC < 1.05) displaySpeedC = Math.round(speedC);
      
      let displayAngVel = angVel;
      if(angVel <= -0.93 && angVel >= -1.05) displayAngVel = -1;
      
      // Round energy value for clarity
      let displayEnergy = energyC;
      if(Math.abs(energyC - 1.0) < 0.1) displayEnergy = 1.0;
      
      // Calculate total energy
      const totalEnergy = energyC + springEnergy;
    
      const anuglarMomentum = rVec.cross(objC.velocity) * objC.mass;
      ez.text(`Particle Energy: ${displayEnergy.toFixed(1)} J, Spring Energy: ${springEnergy.toFixed(1)} J, Total: ${totalEnergy.toFixed(1)} J\nLinear Vel: ${displaySpeedC.toFixed(2)} m/s, Angular Vel: ${displayAngVel.toFixed(2)} rad/s`, vec2(0, 1.6), textOptions).fill("black");
    }

    // Draw a rectangle shadow for a barbell (two particles)
    function drawBarbellBoxShadow(p1, p2) {
      ez.ctx.save();
      ez.ctx.shadowColor = ez.parseColor("rgba(0,0,0,0.55)");
      ez.ctx.shadowBlur = 10;
      ez.ctx.shadowOffsetX = 5;
      ez.ctx.shadowOffsetY = 5;

      const center = vec2(
        (p1.position.x + p2.position.x) * 0.5,
        (p1.position.y + p2.position.y) * 0.5
      );
      const delta = new Vec2(p2.position.x - p1.position.x, p2.position.y - p1.position.y);
      const length = delta.length() + 0.2; // a bit longer than the spring
      const angle = Math.atan2(delta.y, delta.x);
      const thickness = 0.33; // slightly larger than particle diameter
      ez.rect(center, [length, thickness], angle).fill("rgba(0,0,0,0.2)");

      ez.ctx.restore();
    }

    // Draw a rectangle overlay for a barbell (two particles)
    function drawBarbellBox(p1, p2) {
      ez.ctx.lineWidth = 1;
      const center = vec2(
        (p1.position.x + p2.position.x) * 0.5,
        (p1.position.y + p2.position.y) * 0.5
      );
      const delta = new Vec2(p2.position.x - p1.position.x, p2.position.y - p1.position.y);
      const length = delta.length() + 0.2; // a bit longer than the spring
      const angle = Math.atan2(delta.y, delta.x);
      const thickness = 0.33; // slightly larger than particle diameter
      ez.rect(center, [length, thickness], angle).fillAndStroke("#FFB3BAEE", "#2F3437");
    }

    // Start the animation
    setupSimulation();
    ez.callAnimate(animationLoop, true);
  </script>
</body>

</html>